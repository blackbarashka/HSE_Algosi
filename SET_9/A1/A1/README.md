

---
# Графики и их анализ:

## Полностью неупорядоченные наборы строк:
### График времени для каждого алгоритма

![image](https://github.com/user-attachments/assets/178d2ad8-9ba0-4f8e-9aef-c31863a1e009)

#### Сравнения и особенности алгоритмов
-	`STRING QUICKSORT` (тернарная быстрая сортировка) демонстрирует значительное превосходство, опережая все остальные алгоритмы по скорости работы. Для массива из 3000 строк его время выполнения составляет около 0.8 мс, что примерно в 6 раз быстрее стандартного ``QuickSort``.
-	`MSDRadix` и `MSDRadix_Quick` также показывают высокую эффективность (2.2 и 1.6 мс соответственно для 3000 строк), что значительно быстрее стандартных сортировок.
- `STRING MERGESORT` на большом наборе данных (3000 строк) выполняется медленнее своего стандартного аналога, что может быть связано с дополнительными вычислениями для поиска LCP.
- Все адаптированные алгоритмы демонстрируют лучшую масштабируемость на больших наборах данных, что соответствует их теоретической сложности.
- При увеличении размера массива `STRING QUICKSORT` сохраняет почти линейный рост времени выполнения, в то время как стандартный `QuickSort` показывает более выраженную суперлинейную зависимость.

### График сравнений для каждого алгоритма

![image](https://github.com/user-attachments/assets/25851307-2dce-4d8e-b87c-841bfe19099d)

#### Сравнения и особенности алгоритмов

-	``QuickSort`` выполняет на порядок больше посимвольных сравнений, чем специализированные алгоритмы.
-	``MSDRadix`` выполняет наименьшее количество посимвольных сравнений, меньше, чем стандартный `QuickSort`.
-	`STRING QUICKSORT` и `STRING MERGESORT` также демонстрируют значительное сокращение числа сравнений.
#### Соответствие теоретическим оценкам:
-	`QuickSort` и `MergeSort`: Теоретическая сложность O(n log n × m), где m — средняя длина строки, подтверждается практически. График показывает явный суперлинейный рост.
-	`STRING QUICKSORT` и `STRING MERGESORT`: Теоретическая сложность O(nlogn). График демонстрирует более плавный рост, близкий к линейному.
-	`MSDRadix`: Теоретическая сложность O(n × d), где d — длина ключа (в данном случае — число уникальных символов). На графике наблюдается наименьший угол наклона среди всех алгоритмов.


### Обоснование эффективности адаптированных алгоритмов
1.	`STRING QUICKSORT`: Высокая производительность объясняется тернарным разделением по текущему символу, что позволяет группировать строки с одинаковыми префиксами и обрабатывать их вместе, сокращая число сравнений.
2.	`MSDRadix`: Минимальное число сравнений и высокая скорость работы обусловлены поразрядной сортировкой, которая не требует полного сравнения строк и сразу распределяет их по "корзинам" соответственно символам на каждой позиции.
3.	`MSDRadix_Quick`: Показывает хорошую эффективность благодаря комбинированному подходу, когда для небольших массивов применяется быстрая тернарная сортировка, а для крупных — поразрядная сортировка.
4.	`STRING MERGESORT` целесообразно применять в ситуациях, где важна стабильность сортировки, несмотря на его относительно более низкую производительность среди адаптированных алгоритмов.

---
## Обратно отсортированные данные:
### График времени для каждого алгоритма

![image](https://github.com/user-attachments/assets/9689fee2-f211-4b9d-afdd-da490c0f135b)

#### Сравнения и особенности алгоритмов
-	Все алгоритмы демонстрируют более резкий рост времени выполнения на больших размерах массива по сравнению со случайными данными.
-	`STRING QUICKSORT` показывает исключительную эффективность на обратно отсортированных данных, выполняясь значительно быстрее всех других алгоритмов.
-	`STRING MERGESORT` демонстрирует наихудшую производительность при больших размерах массива, что существенно хуже, чем на случайных данных.
-	`MSDRadix` и `MSDRadix_Quick` сохраняют стабильную производительность.
-	`QuickSort` показывает умеренное время (~5.1 мс для 3000 строк), что лучше, чем `MergeSort` (~12.7 мс).
-	`STRING QUICKSORT` сохраняет практически линейный рост даже на больших массивах, что говорит о его устойчивости к обратному порядку элементов.

### График сравнений для каждого алгоритма

![image](https://github.com/user-attachments/assets/c8099f54-317a-48a4-a3bf-eb056e9957f3)


#### Сравнения и особенности алгоритмов
-	`QuickSort` по-прежнему выполняет наибольшее количество посимвольных сравнений, что демонстрирует его неэффективность на строковых данных независимо от порядка элементов.
-	`MSDRadix` выполняет наименьшее количество сравнений, что в 30 раз меньше, чем стандартный `QuickSort`.
-	`STRING QUICKSORT` и `STRING MERGESORT` демонстрируют близкие значения (~25,000-30,000 для 3000 строк), при этом `STRING QUICKSORT` требует несколько меньше сравнений.


### Обоснование эффективности адаптированных алгоритмов
1.	`STRING QUICKSORT`: Высокая эффективность тернарного алгоритма на обратно отсортированных данных объясняется его способностью быстро идентифицировать и группировать строки с общими префиксами, не требуя полного сравнения строк на каждом шаге.
2.	`STRING MERGESORT`: Неожиданное ухудшение производительности может быть связано с дополнительными затратами на вычисление LCP для строк, которые, будучи обратно отсортированными, имеют минимальные общие префиксы, что снижает преимущество алгоритма.
3.	`MSDRadix` и `MSDRadix_Quick`: Стабильная производительность этих алгоритмов объясняется тем, что поразрядная сортировка по определению не зависит от исходного порядка данных, так как распределяет элементы по "корзинам" в соответствии с символами в каждой позиции.
4.	
---




## Почти отсортированные данные:
### График времени для каждого алгоритма

![image](https://github.com/user-attachments/assets/2c87b55f-9d91-4668-9308-04e2af48a514)

#### Сравнения и особенности алгоритмов
-	`STRING QUICKSORT` показывает наилучшую производительность, быстрее всех других алгоритмов.
-	`MSDRadix_Quick` и простой `MSDRadix` демонстрируют хорошие результаты.
-	`MergeSort` оказывается наименее эффективным (~8.0 мс для 3000 строк), что хуже даже чем `STRING MERGESORT` (~7.1 мс).
-	`QuickSort` показывает умеренное время выполнения (~4.4 мс для 3000 строк), занимая промежуточное положение.
-	`MergeSort` и `STRING MERGESORT` демонстрируют резкий рост времени выполнения после 2000 элементов, указывая на их неэффективность для больших почти отсортированных массивов.
-	`STRING QUICKSORT` сохраняет практически линейное масштабирование на всем диапазоне, что свидетельствует о его оптимальности для почти отсортированных данных.
-	`QuickSort` показывает нелинейный рост с небольшими скачками (особенно заметно при 1500 и 3000 элементах), что может указывать на зависимость от конкретного распределения перемешанных элементов.
  
### График сравнений для каждого алгоритма

![image](https://github.com/user-attachments/assets/93635be1-0d77-4527-880f-9141d3495dc7)




-	`QuickSort` по-прежнему выполняет наибольшее количество посимвольных сравнений (~450,000 для 3000 строк), что на порядок больше, чем у всех специализированных алгоритмов.
-	`MSDRadix` и `MSDRadix_Quick` показывают наименьшее количество сравнений (~10,000-15,000 для 3000 строк).
-	`STRING QUICKSORT` и `STRING MERGESORT` выполняют умеренное количество сравнений (~30,000-35,000 для 3000 строк).
-	`QuickSort` демонстрирует почти такое же количество сравнений, как и для полностью неупорядоченных или обратно отсортированных данных, что указывает на его нечувствительность к исходному порядку строк.


### Обоснование эффективности адаптированных алгоритмов
1.	`STRING QUICKSORT`: Высокая эффективность на почти отсортированных данных объясняется тем, что тернарный алгоритм быстро выявляет и обрабатывает группы строк с общими префиксами, а количество перемешанных элементов невелико, что минимизирует число рекурсивных вызовов.
2.	`MSDRadix` и `MSDRadix_Quick`: Хорошие результаты связаны с тем, что поразрядные методы не зависят от исходного порядка данных. При этом `MSDRadix_Quick` получает преимущество от быстрого переключения на тернарную сортировку для небольших подмассивов.
3.	`MergeSort` и `STRING MERGESORT`: Низкая производительность объясняется тем, что слияние в этих алгоритмах не может эффективно использовать преимущества почти отсортированных данных, в отличие от их эффективности на полностью отсортированных массивах.
4.	`QuickSort`: Промежуточная производительность связана с тем, что при почти отсортированных данных выбор опорного элемента может оказаться более благоприятным, чем на полностью случайных данных, но алгоритм всё равно выполняет слишком много избыточных посимвольных сравнений
